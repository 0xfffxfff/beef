{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Beef.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.15;\n\n////////////////////////////////////////////////////////////////////////\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                     need no permission                             //\n//                     grazing on the lush grass hills                //\n//                     both beef and babe chew                        //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                       0xfff.eth    //\n//                                                                    //\n////////////////////////////////////////////////////////////////////////\n\nimport \"./BeefERC721.sol\";\n\nimport {ConceptStruct} from \"../libraries/ConceptStruct.sol\";\nimport {Render} from \"../libraries/Render.sol\";\nimport {Util} from \"../libraries/Util.sol\";\n\nuint256 constant PERMISSIONLESS = 1;\nuint256 constant NO_EXTERNALITIES = 2;\nuint256 constant OPENING_HOURS = 3;\nuint256 constant DEAD_BEEF = 4;\nuint256 constant MUTUAL_A = 5;\nuint256 constant MUTUAL_B = 6;\nuint256 constant FAIR_PRICE = 7;\nuint256 constant BEEF_BABE = 8;\nuint256 constant SATED = 9;\nuint256 constant DARK = 10;\nuint256 constant RETRACTED = 11;\nuint256 constant BAD_BEEF = 12;\nuint256 constant EOA = 13;\nuint256 constant SAMEBLOCK_I = 14;\nuint256 constant SAMEBLOCK_II = 15;\nuint256 constant SAMEBLOCK_III = 16;\nuint256 constant LIMITED_USE = 17;\nuint256 constant DEAF_BABE = 18;\nuint256 constant DECREASE = 19;\nuint256 constant SECRET_POEM = 20;\nuint256 constant LOCUS = 21;\nuint256 constant PERMANENCE_I = 22;\nuint256 constant BEEF_BEEF = 23;\nuint256 constant DEPENDENT_A = 24;\nuint256 constant DEPENDENT_B = 25;\nuint256 constant LIGHT = 26;\nuint256 constant INCREASE = 27;\nuint256 constant DEAD_BABE = 28;\nuint256 constant CONTINUOUS = 29;\nuint256 constant SECRET_JOKE = 30;\nuint256 constant PERMANENCE_II = 31;\nuint256 constant DEAF_BEEF = 32;\nuint256 constant MAXIMALISM = 33;\nuint256 constant COINBASE = 34;\nuint256 constant BABE_BEEF = 35;\nuint256 constant BEEF_FACE = 36;\nuint256 constant FEED_BEEF = 37;\nuint256 constant SECRET_TRUTH = 38;\nuint256 constant CHROMATIC = 39;\nuint256 constant UNWIELDY = 40;\nuint256 constant BAD_BABE = 41;\nuint256 constant TRANSITORY_OWNERSHIP = 42;\n\ncontract Beef is BeefERC721 {\n\n    /*//////////////////////////////////////////////////////////////\n                             Constructor\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() BeefERC721(\"BEEF I\", \"BEEF\") {\n        _mint(block.coinbase, TRANSITORY_OWNERSHIP);\n        totalSupply++;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Tokens / Mint\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply = 0;\n    uint256 public editionSize = 42;\n    uint256 constant public price = 0.1 ether;\n\n    function mint(uint256 _tokenId) external payable {\n        require(_tokenId > 0 && _tokenId <= editionSize); // starts at 1\n        uint256 mintPrice = (_tokenId == UNWIELDY ? (1 ether + price) : price);\n        require(msg.value == mintPrice);\n        _mint(msg.sender, _tokenId);\n        totalSupply++;\n    }\n\n    function withdraw(address payable _to) public onlyArtist {\n        (bool success,) = _to.call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Concept Data\n    //////////////////////////////////////////////////////////////*/\n\n    mapping (uint256 => ConceptStruct.Concept) concepts;\n    mapping (uint256 => uint256) tokenIdToConcept;\n\n    function setConceptData(ConceptStruct.Concept[] memory _concepts) public onlyArtist {\n        for (uint i = 0; i < _concepts.length; i++) {\n            ConceptStruct.Concept memory concept = _concepts[i];\n            uint256 conceptId = concept._editionTokenRangeStart;\n            concepts[conceptId] = concept;\n            for (uint j = concept._editionTokenRangeStart; j < concept._editionTokenRangeStart + concept._editionSize; j++) {\n                tokenIdToConcept[j] = conceptId;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Custom State\n    //////////////////////////////////////////////////////////////*/\n\n    mapping (uint256 => uint256) sameBlockAt;\n    mapping (uint256 => address) sameBlockTo;\n    uint256 public fairPrice = 0.1 ether;\n    uint96 public increasable = 1;\n    uint96 public decreasable = 1111111111111111111111111111;\n    uint256 public transfersLeft = 7;\n\n    /*//////////////////////////////////////////////////////////////\n                            Custom Methods\n    //////////////////////////////////////////////////////////////*/\n\n    function buyAtFairPrice() external payable {\n        // Anyone can buy at fair price\n        if (_ownerOf[FAIR_PRICE] == address(0)) {\n            require(msg.value >= fairPrice);\n            _mint(msg.sender, FAIR_PRICE);\n        } else if (msg.value > fairPrice) {\n            fairPrice = msg.value;\n            _transferFromInternal(_ownerOf[FAIR_PRICE], msg.sender, FAIR_PRICE);\n        } else {\n            revert();\n        }\n    }\n\n    function increase() external payable {\n        // Anyone can increase\n        increasable++;\n    }\n\n    function decrease() external payable {\n        // Anyone can decrease\n        decreasable++;\n    }\n\n    function retract() external onlyArtist {\n        // The artist can retract this piece at any time\n        _transferFromInternalNoHooksAndChecks(_ownerOf[RETRACTED], artist(), RETRACTED);\n    }\n\n    function isOpenHours() public view returns (bool) {\n        // Opening hours are from  9-5 UTC\n        uint256 daytime = block.timestamp % (24 * 3600);\n        return (daytime >= 9 * 3600) && (daytime <= 17 * 3600);\n    }\n\n    function whereIs(address _address) public pure returns (uint256 x, uint256 y , uint256 z) {\n        // This piece will output three spacial coordinates for the current address.\n        // It can be used to spacially relate addresses\n        uint256 addressNumber = uint256(keccak256(abi.encodePacked(_address)));\n        x = addressNumber % 10e4;\n        y = (addressNumber >> 8) % 10e4;\n        z = (addressNumber >> 16) % 10e3;\n    }\n\n    function updateTransitory() external {\n        _transferFromInternal(_ownerOf[TRANSITORY_OWNERSHIP], block.coinbase, TRANSITORY_OWNERSHIP);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          Hooks and Overrides\n    //////////////////////////////////////////////////////////////*/\n\n    function ownerOf(uint256 id) public view override returns (address) {\n        if (id == TRANSITORY_OWNERSHIP) {\n            return block.coinbase;\n        } else if (\n            (id == PERMANENCE_I  && block.number % 2 == 0) ||\n            (id == PERMANENCE_II && block.number % 2 == 1)\n        ) {\n            revert(\"Half of the time\");\n        } else if (id == OPENING_HOURS) {\n            require(isOpenHours(), \"Currently closed\");\n        }\n        return super.ownerOf(id);\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == block.coinbase) {\n            return 1 + _balanceOf[owner];\n        }\n        return super.balanceOf(owner);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override payable {\n        if (id == PERMISSIONLESS) {\n            _transferFromInternal(from, to, id);\n        } else if (id == TRANSITORY_OWNERSHIP) {\n            _transferFromInternal(from, to, id);\n        } else {\n            super.transferFrom(from, to, id);\n        }\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override payable {\n        if (id == PERMISSIONLESS) {\n            _transferFromInternal(from, to, id);\n        } else if (id == TRANSITORY_OWNERSHIP) {\n            _transferFromInternal(from, to, id);\n        } else {\n            super.transferFrom(from, to, id);\n        }\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public override payable {\n        if (id == PERMISSIONLESS) {\n            _transferFromInternal(from, to, id);\n        } else if (id == TRANSITORY_OWNERSHIP) {\n            _transferFromInternal(from, to, id);\n        } else {\n            super.transferFrom(from, to, id);\n        }\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {}\n\n    function _beforeTokenTransfer(\n        address /* from */,\n        address to,\n        uint256 tokenId\n    ) internal override returns (bool) {\n        if (tokenId == SATED) {\n\n            // PERMANENCE SATED\n            // This piece can only be transfered as the only transaction in a block\n            uint256 waste; for (uint256 i = 0; i < 159160; i++) waste++;\n\n        } else if (\n            (tokenId == PERMANENCE_I  && block.number % 2 == 0) ||\n            (tokenId == PERMANENCE_II && block.number % 2 == 1)\n        ) {\n\n            // PERMANENCE I & II\n            // This piece exists half of the time\n            revert(\"Half of the time\");\n\n        } else if (tokenId == TRANSITORY_OWNERSHIP) {\n\n            // TRANSITORY OWNERSHIP\n            // This piece will always belong to the current validator\n            require(to == block.coinbase);\n\n        } else if (tokenId == OPENING_HOURS) {\n\n            // OPENING HOURS\n            // This piece has opening hours during which it exists and can be transferred\n            require(isOpenHours(), \"Currently closed\");\n\n        } else if (tokenId == DEAD_BEEF || tokenId == BEEF_BEEF || tokenId == FEED_BEEF || tokenId == DEAF_BEEF\n                || tokenId == BAD_BEEF  || tokenId == BEEF_FACE || tokenId == BABE_BEEF || tokenId == BEEF_BABE\n                || tokenId == BAD_BABE  || tokenId == DEAF_BABE || tokenId == DEAD_BABE\n        ) {\n\n            // DEAD BEEF\n            // This piece can only be held by an address starting with DEAD and ending with BEEF\n            bytes20 addr = bytes20(to);\n            if (\n                (\n                    (tokenId == DEAD_BEEF && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"dead00000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == BEEF_BEEF && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"beef00000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == FEED_BEEF && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"feed00000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == DEAF_BEEF && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"deaf00000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == BAD_BEEF && (addr & hex\"fff000000000000000000000000000000000ffff\" == hex\"bad000000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == BEEF_FACE && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"beef00000000000000000000000000000000face\"))\n                    ||\n                    (tokenId == BABE_BEEF && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"babe00000000000000000000000000000000beef\"))\n                    ||\n                    (tokenId == BEEF_BABE && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"beef00000000000000000000000000000000babe\"))\n                    ||\n                    (tokenId == BAD_BABE && (addr & hex\"fff000000000000000000000000000000000ffff\" == hex\"bad000000000000000000000000000000000babe\"))\n                    ||\n                    (tokenId == DEAF_BABE && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"deaf00000000000000000000000000000000babe\"))\n                    ||\n                    (tokenId == DEAD_BABE && (addr & hex\"ffff00000000000000000000000000000000ffff\" == hex\"dead00000000000000000000000000000000babe\"))\n                ) == false\n            ) {\n                revert(\"No beef\");\n            }\n\n        } else if (tokenId >= SAMEBLOCK_I && tokenId <= SAMEBLOCK_III) {\n\n            // SAME BLOCK\n            // The three pieces from this edition can only be transferred in the same block\n            uint256 dependentIdA = tokenId == SAMEBLOCK_I ? SAMEBLOCK_II : SAMEBLOCK_I;\n            uint256 dependentIdB = tokenId == SAMEBLOCK_I ? SAMEBLOCK_III : tokenId == SAMEBLOCK_II ? SAMEBLOCK_III : SAMEBLOCK_II;\n            if (sameBlockAt[dependentIdA] == block.number && sameBlockAt[dependentIdB] == block.number) {\n                _ownerOf[dependentIdA] == address(0)\n                    ? _mintNoHooks(sameBlockTo[dependentIdA], dependentIdA)\n                    : _transferFromInternalNoHooksAndChecks(_ownerOf[dependentIdA], sameBlockTo[dependentIdA], dependentIdA);\n                _ownerOf[dependentIdB] == address(0)\n                    ? _mintNoHooks(sameBlockTo[dependentIdB], dependentIdB)\n                    : _transferFromInternalNoHooksAndChecks(_ownerOf[dependentIdB], sameBlockTo[dependentIdB], dependentIdB);\n                return true;\n            } else {\n                sameBlockAt[tokenId] = block.number;\n                sameBlockTo[tokenId] = to;\n                return false;\n            }\n\n        } else if (tokenId == DEPENDENT_A || tokenId == DEPENDENT_B) {\n\n            // CO-DEPENDENT\n            // The two pieces of this edition are co-dependent. A piece can only be acquired if the sum of the\n            // first three and of the last three digits of both the owning addresses are smaller than or equal\n            // to 0xFFF = 4095 respectively\n            uint256 dependentId = tokenId == DEPENDENT_A ? DEPENDENT_B : DEPENDENT_A;\n            if (\n                (\n                    uint160(_ownerOf[dependentId]) % 4096 + uint160(to) % 4096 < 4096\n                    &&\n                    uint160(bytes20(_ownerOf[dependentId]) >> 148) % 4096 + uint160(bytes20(to) >> 148) % 4096 < 4096\n                ) == false\n            ) {\n                revert(\"Codependent\");\n            }\n\n        } else if (tokenId == MUTUAL_A || tokenId == MUTUAL_B) {\n\n            // MUTUALLY EXCLUSIVE\n            // The two pieces of this edition are mutually exclusive. Each piece can only be\n            // owned if the other owning address has no matching digits\n            uint256 dependentId = tokenId == MUTUAL_A ? MUTUAL_B : MUTUAL_A;\n            bytes20 bytesDependent = bytes20(_ownerOf[dependentId]);\n            bytes20 bytesTo = bytes20(to);\n            for (uint i = 0; i < 40; i++) {\n                if (uint160(bytesDependent >> i * 4) % 16 == uint160(bytesTo >> i * 4) % 16) {\n                    revert(\"Mutually exclusive\");\n                }\n            }\n\n        } else if (tokenId == LIGHT) {\n\n            // LIGHT\n            // This piece can only be held by addresses containing at least 13 instances of F and no instances of 0\n            bytes20 bytesTo = bytes20(to);\n            uint16 count;\n            for (uint i ; i < 40; i++) {\n                if (uint160(bytesTo >> i * 4) % 16 == 0) break;\n                if (uint160(bytesTo >> i * 4) % 16 == 15) count++;\n                if (count > 13) return true;\n            }\n            revert();\n\n        } else if (tokenId == DARK) {\n\n            // DARK\n            // This piece can only be held by addresses containing at least 13 instances of 0 and no instances of F\n            bytes20 bytesTo = bytes20(to);\n            uint16 count;\n            for (uint i ; i < 40; i++) {\n                if (uint160(bytesTo >> i * 4) % 16 == 15) break;\n                if (uint160(bytesTo >> i * 4) % 16 == 0) count++;\n                if (count > 13) return true;\n            }\n            revert();\n\n        } else if (tokenId == CHROMATIC) {\n\n            // CHROMATIC\n            // This piece can only be held by addresses containg at least 1 of each hexadecimal digit\n            bytes20 bytesTo = bytes20(to);\n            uint256 bitmap;\n            for (uint256 i; i < 40; i++) {\n                bitmap |= (1 << (uint160(bytesTo >> i * 4) % 16));\n                if (bitmap == 65535) return true;\n            }\n            revert();\n\n        } else if (tokenId == NO_EXTERNALITIES) {\n\n            // NO EXTERNALITIES\n            // This piece can only be held by a contract\n            uint size;\n            assembly { size := extcodesize(to) }\n            require(size > 0);\n\n        } else if (tokenId == EOA) {\n\n            // EOA\n            // This piece cannot be held by a contract\n            uint size;\n            assembly { size := extcodesize(to) }\n            require(size == 0);\n            require(tx.origin == msg.sender);\n\n        } else if (tokenId == LIMITED_USE) {\n\n            // LIMITED USE\n            // This piece can only be transfered 7 times after which it will self destruct\n            if (transfersLeft > 0) {\n                transfersLeft--;\n            } else {\n                // bye\n                _transferFromInternalNoHooksAndChecks(_ownerOf[LIMITED_USE], address(0xdEaD), LIMITED_USE);\n                return false; // don't transfer\n            }\n\n        } else if (tokenId == UNWIELDY) {\n\n            // UNWIELDY\n            // This piece requires burning 1 ETH to be transfered.\n            require(msg.value >= 1 ether && msg.value <= 1 ether + price);\n            (bool success,) = address(0).call{value: 1 ether}(\"\"); // good bye\n            require (success);\n\n        } else if (tokenId == COINBASE) {\n\n            // COINBASE\n            // This piece can only transfered to the block.coinbase address.\n            // As such it can only be received by validators\n            require(to == block.coinbase);\n\n        } else if (tokenId == CONTINUOUS) {\n\n            // CONTINUOUS\n            // This piece can only be transfered to an address that has the\n            // first three digits of the previous address as its last three\n            bytes20 bytesFrom = bytes20(_ownerOf[CONTINUOUS]);\n            bytes20 bytesTo = bytes20(to);\n            for (uint i = 0; i < 3; i++) {\n                if (uint160(bytesFrom >> (i) * 4) % 16 != uint160(bytesTo >> (40 - (3 - i)) * 4) % 16) {\n                    revert();\n                }\n            }\n\n        }\n\n        return true;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Metadata\n    ///////////////////////////////////////////////////////////////////////////\n\n    function renderSVG(uint256 _tokenId) external view returns (string memory) {\n        ConceptStruct.Concept memory concept = _getConceptFromTokenId(_tokenId);\n        return Render.renderSVG(_tokenId, concept, font);\n    }\n\n    function renderSVGBase64(uint256 _tokenId) external view returns (string memory) {\n        ConceptStruct.Concept memory concept = _getConceptFromTokenId(_tokenId);\n        return Render.renderSVGBase64(_tokenId, concept, font);\n    }\n\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        if (\n            (_tokenId == PERMANENCE_I  && block.number % 2 == 0) ||\n            (_tokenId == PERMANENCE_II && block.number % 2 == 1)\n        ) {\n            revert(\"Half of the time\");\n        } else if (_tokenId == OPENING_HOURS) {\n            require(isOpenHours(), \"Currently closed\");\n        }\n        require(_ownerOf[_tokenId] != address(0), \"NOT_MINTED\");\n        ConceptStruct.Concept memory concept = _getConceptFromTokenId(_tokenId);\n        return Render.tokenURI(_tokenId, concept, font);\n    }\n\n    function _getConceptFromTokenId(uint256 _tokenId) private view returns (ConceptStruct.Concept memory) {\n        uint256 conceptId = tokenIdToConcept[_tokenId];\n        ConceptStruct.Concept memory concept = concepts[conceptId];\n\n        if (_tokenId == FAIR_PRICE) {\n\n            bytes32[] memory statusText = new bytes32[](1);\n            statusText[0] = bytes32(abi.encodePacked(\"Price: \", Util.uint256ToString(uint256(fairPrice / 10e17)), \".\", Util.uint256ToString(uint256((fairPrice / 10e16) % 10)), (fairPrice / 10e15) % 10 == 0 ? \"\" : Util.uint256ToString(uint256((fairPrice / 10e15) % 10)), \" ETH\"));\n            concept._statusText = statusText;\n\n        } else if (_tokenId == LIMITED_USE) {\n\n            bytes32[] memory statusText = new bytes32[](1);\n            statusText[0] = bytes32(abi.encodePacked(\"Transfers Left: \", Util.uint256ToString(uint256(transfersLeft))));\n            concept._statusText = statusText;\n\n        } else if (_tokenId == INCREASE) {\n\n            concept._title = bytes32(abi.encodePacked(Util.uint256ToString(uint256(increasable))));\n\n        } else if (_tokenId == DECREASE) {\n\n            concept._title = bytes32(abi.encodePacked(Util.uint256ToString(uint256(decreasable))));\n\n        } else if (_tokenId == OPENING_HOURS) {\n\n            bytes32[] memory statusText = new bytes32[](1);\n            statusText[0] = bytes32(abi.encodePacked(\"Currently \", isOpenHours() ? \"Open\" : \"Closed\"));\n            concept._statusText = statusText;\n\n        } else if (_tokenId == LOCUS) {\n\n            bytes32[] memory statusText = new bytes32[](3);\n            uint256 x; uint256 y; uint256 z;\n            (x,y,z) = whereIs(_ownerOf[_tokenId]);\n            statusText[0] = bytes32(abi.encodePacked(\n                Util.uint256ToString(x), \", \",\n                Util.uint256ToString(y), \", \",\n                Util.uint256ToString(z)\n            ));\n            concept._statusText = statusText;\n\n        }\n\n        return concept;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Font\n    ///////////////////////////////////////////////////////////////////////////\n\n    string private font = \"data:application/font-woff2;charset=utf-8;base64,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\";\n\n}\n"
    },
    "contracts/BeefERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @notice Adopted from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract BeefERC721 is Ownable {\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                                  VIEW\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        address owner = _ownerOf[id];\n        require(owner != address(0), \"NOT_MINTED\");\n        return owner;\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 VANITY\n    //////////////////////////////////////////////////////////////*/\n\n    function artist() public view returns (address) {\n        return owner();\n    }\n\n    modifier onlyArtist {\n        require(msg.sender == artist());\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual payable {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _transferFromInternal(from, to, id);\n    }\n\n    function _transferFromInternal(\n        address from,\n        address to,\n        uint256 id\n    ) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        bool doTransfer = _beforeTokenTransfer(from, to, id);\n        if (!doTransfer) return;\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n\n        _afterTokenTransfer(from, to, id);\n    }\n\n    function _transferFromInternalNoHooksAndChecks(\n        address from,\n        address to,\n        uint256 id\n    ) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual payable;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        bool doTransfer =_beforeTokenTransfer(address(0), to, id);\n        if (!doTransfer) return;\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    function _mintNoHooks(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual returns (bool) {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "libraries/Background.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {SVG} from \"./SVG.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Background {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(bool isBeef) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"rect\",\n                SVG.rectAttributes({\n                    _width: \"100%\",\n                    _height: \"100%\",\n                    _fill: isBeef ? \"#BA2219\" : \"#000\",\n                    _attributes: \"\"\n                })\n            );\n    }\n}\n"
    },
    "libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    function encode(string memory _data) internal pure returns (string memory) {\n        return encode(bytes(_data));\n    }\n\n    function encode(bytes memory _data) internal pure returns (string memory) {\n        if (_data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((_data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := _data\n            let endPtr := add(dataPtr, mload(_data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(_data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "libraries/ConceptStruct.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nlibrary ConceptStruct {\n    struct Concept {\n        uint256 _editionTokenRangeStart;\n        uint256 _editionSize;\n        bytes32 _title;\n        bytes32[] _bodyText;\n        bytes32[] _smallPrintText;\n        bytes32[] _statusText;\n    }\n}"
    },
    "libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Base64} from \"./Base64.sol\";\nimport {Util} from \"./Util.sol\";\n\nlibrary Metadata {\n    string constant JSON_BASE64_HEADER = \"data:application/json;base64,\";\n    string constant SVG_XML_BASE64_HEADER = \"data:image/svg+xml;base64,\";\n\n    function encodeMetadata(\n        uint256 _tokenId,\n        string memory _name,\n        string memory _description,\n        // string memory _attributes,\n        // string memory _backgroundColor,\n        string memory _svg\n    ) internal pure returns (string memory) {\n        string memory metadata = string.concat(\n            \"{\",\n            Util.keyValue(\"tokenId\", Util.uint256ToString(_tokenId)),\n            \",\",\n            Util.keyValue(\"name\", _name),\n            \",\",\n            Util.keyValue(\"description\", _description),\n            // \",\",\n            // Util.keyValueNoQuotes(\"attributes\", _attributes),\n            // \",\",\n            // Util.keyValue(\"backgroundColor\", _backgroundColor),\n            \",\",\n            Util.keyValue(\"image\", _encodeSVG(_svg)),\n            \"}\"\n        );\n\n        return _encodeJSON(metadata);\n    }\n\n    /// @notice base64 encode json\n    /// @param _json, stringified json\n    /// @return string, bytes64 encoded json with prefix\n    function _encodeJSON(string memory _json) internal pure returns (string memory) {\n        return string.concat(JSON_BASE64_HEADER, Base64.encode(_json));\n    }\n\n    /// @notice base64 encode svg\n    /// @param _svg, stringified json\n    /// @return string, bytes64 encoded svg with prefix\n    function _encodeSVG(string memory _svg) internal pure returns (string memory) {\n        return string.concat(SVG_XML_BASE64_HEADER, Base64.encode(bytes(_svg)));\n    }\n}\n"
    },
    "libraries/Render.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Metadata} from \"./Metadata.sol\";\nimport {Util} from \"./Util.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {Background} from \"./Background.sol\";\nimport {TextBody} from \"./TextBody.sol\";\nimport {TextLine} from \"./TextLine.sol\";\nimport {TextEdition} from \"./TextEdition.sol\";\nimport {TextOf} from \"./TextOf.sol\";\nimport {Traits} from \"./Traits.sol\";\nimport {SVG} from \"./SVG.sol\";\nimport {ConceptStruct} from \"./ConceptStruct.sol\";\n\n/// @notice Adopted from Bibos (0xf528e3381372c43f5e8a55b3e6c252e32f1a26e4)\nlibrary Render {\n    string public constant description =\n        \"The BEEF series.\";\n\n    /*//////////////////////////////////////////////////////////////\n                                TOKENURI\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 _tokenId, ConceptStruct.Concept memory concept, string memory base64font) internal pure returns (string memory) {\n        bytes memory descriptionConcat;\n        for (uint i = 0; i < concept._bodyText.length; i++) {\n            descriptionConcat = abi.encodePacked(descriptionConcat, Util.bytes32ToBytes(concept._bodyText[i]));\n        }\n        return\n            Metadata.encodeMetadata({\n                _tokenId: _tokenId,\n                _name: Util.bytes32ToString(concept._title),\n                _description: string(abi.encodePacked(descriptionConcat)),\n                _svg: _svg(_tokenId, concept, base64font)\n            });\n    }\n\n    function renderSVG(uint256 _tokenId, ConceptStruct.Concept memory concept, string memory base64font) internal pure returns (string memory) {\n        return _svg(_tokenId, concept, base64font);\n    }\n\n    function renderSVGBase64(uint256 _tokenId, ConceptStruct.Concept memory concept, string memory base64font) internal pure returns (string memory) {\n        return Metadata._encodeSVG(_svg(_tokenId, concept, base64font));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _svg(\n        uint256 _tokenId,\n        ConceptStruct.Concept memory _concept,\n        string memory base64font\n    ) internal pure returns (string memory) {\n        bool isBeef = _tokenId == 4 || _tokenId == 8 || _tokenId == 12 || _tokenId == 23 || _tokenId == 32 || _tokenId == 35 || _tokenId == 36 || _tokenId == 37;\n        return\n            SVG.element(\n                \"svg\",\n                SVG.svgAttributes(),\n                string.concat(\n                    '<defs><style>',\n                    '@font-face {font-family: \"Norw\";src: url(\"',\n                        base64font,\n                    '\");}',\n                    'text {text-transform: uppercase;'\n                    '}</style></defs>'\n                ),\n                Background.render(isBeef),\n                _renderText(_tokenId, _concept)\n            );\n    }\n\n    function _renderText(uint256 _tokenId, ConceptStruct.Concept memory _concept) internal pure returns (string memory) {\n        // uint256 titleOffset = 155;\n        // uint256 bodyOffset = 155 + 60;\n        uint256 smallPrintOffset = 215 + _concept._bodyText.length * 30 + (_concept._bodyText.length > 0 ? 50 : 0);\n        uint256 statusOffset = smallPrintOffset + _concept._smallPrintText.length * 20 + (_concept._smallPrintText.length > 0 ? 50 : 0);\n        return SVG.element(\n            \"g\",\n            \"\",\n            TextLine.render(_concept._title, 155, false),\n            TextBody.render(_concept._bodyText, 215, false),\n            TextBody.render(_concept._statusText, statusOffset, false),\n            TextBody.render(_concept._smallPrintText, smallPrintOffset, true),\n            TextEdition.render(bytes32(abi.encodePacked(Util.uint256ToString(_tokenId)))),\n            TextOf.render(_editionTextConcat(_tokenId, _concept))\n        );\n    }\n\n    function _editionTextConcat(uint256 _tokenId, ConceptStruct.Concept memory _concept) internal pure returns (bytes32) {\n        uint256 editionCount = _tokenId - _concept._editionTokenRangeStart + 1;\n        return bytes32(abi.encodePacked(Util.uint256ToString(editionCount), \" of \", Util.uint256ToString(_concept._editionSize)));\n    }\n\n    function _name(uint256 _tokenId) internal pure returns (string memory) {\n        return string.concat(\"Beef \", Util.uint256ToString(_tokenId, 4));\n    }\n}\n"
    },
    "libraries/SVG.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary SVG {\n    /*//////////////////////////////////////////////////////////////\n                                 ELEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    function element(string memory _type, string memory _attributes) internal pure returns (string memory) {\n        return string.concat(\"<\", _type, \" \", _attributes, \"/>\");\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _children\n    ) internal pure returns (string memory) {\n        return string.concat(\"<\", _type, \" \", _attributes, \">\", _children, \"</\", _type, \">\");\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2, _child3));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2, _child3, _child4));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2, _child3, _child4, _child5));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6\n    ) internal pure returns (string memory) {\n        return element(_type, _attributes, string.concat(_child1, _child2, _child3, _child4, _child5, _child6));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7\n    ) internal pure returns (string memory) {\n        return\n            element(_type, _attributes, string.concat(_child1, _child2, _child3, _child4, _child5, _child6, _child7));\n    }\n\n    function element(\n        string memory _type,\n        string memory _attributes,\n        string memory _child1,\n        string memory _child2,\n        string memory _child3,\n        string memory _child4,\n        string memory _child5,\n        string memory _child6,\n        string memory _child7,\n        string memory _child8\n    ) internal pure returns (string memory) {\n        return\n            element(_type, _attributes, string.concat(_child1, _child2, _child3, _child4, _child5, _child6, _child7, _child8));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ATTRIBUTES\n    //////////////////////////////////////////////////////////////*/\n\n    function svgAttributes() internal pure returns (string memory) {\n        return\n            string.concat(\n                'xmlns=\"http://www.w3.org/2000/svg\" '\n                'xmlns:xlink=\"http://www.w3.org/1999/xlink\" '\n                'width=\"100%\" '\n                'height=\"100%\" '\n                'viewBox=\"0 0 511 619\" ',\n                'preserveAspectRatio=\"xMidYMid meet\" ',\n                'fill=\"none\" '\n            );\n    }\n\n    function textAttributes(\n        string[2] memory _coords,\n        string memory _fontSize,\n        string memory _fontFamily,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"x=\",\n                Util.quote(_coords[0]),\n                \"y=\",\n                Util.quote(_coords[1]),\n                \"font-size=\",\n                Util.quote(string.concat(_fontSize, \"px\")),\n                \"font-family=\",\n                Util.quote(_fontFamily),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function rectAttributes(\n        string memory _width,\n        string memory _height,\n        string memory _fill,\n        string memory _attributes\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"width=\",\n                Util.quote(_width),\n                \"height=\",\n                Util.quote(_height),\n                \"fill=\",\n                Util.quote(_fill),\n                \" \",\n                _attributes,\n                \" \"\n            );\n    }\n\n    function filterAttribute(string memory _id) internal pure returns (string memory) {\n        return string.concat(\"filter=\", '\"', \"url(#\", _id, \")\", '\" ');\n    }\n}\n"
    },
    "libraries/TextBody.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextBody {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(bytes32[] memory _text, uint256 yOffset, bool _small) internal pure returns (string memory) {\n        string memory textLines = \"\";\n\n        for (uint8 index = 0; index < _text.length; ++index) {\n            textLines = string.concat(\n                textLines,\n                SVG.element(\n                    \"text\",\n                    SVG.textAttributes({\n                        _fontSize: _small ? \"14\" : \"26\",\n                        _fontFamily: \"Norw, 'Courier New', monospace\",\n                        _coords: [\n                            \"60\",\n                            Util.uint256ToString(yOffset + index * (_small ? 20 : 30))\n                        ],\n                        _fill: \"white\",\n                        _attributes: \"\"\n                    }),\n                    Util.bytes32ToString(_text[index])\n                )\n            );\n        }\n\n        return\n            textLines;\n    }\n}\n"
    },
    "libraries/TextEdition.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextEdition {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(bytes32 _text) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"text\",\n                SVG.textAttributes({\n                    _fontSize: \"26\",\n                    _fontFamily: \"Norw, 'Courier New', monospace\",\n                    _coords: [\"12\", \"35\"],\n                    _fill: \"white\",\n                    _attributes: \"\"\n                }),\n                Util.bytes32ToString(_text)\n            );\n    }\n}\n"
    },
    "libraries/TextLine.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextLine {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(bytes32 _text, uint256 yOffset, bool _small) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"text\",\n                SVG.textAttributes({\n                    _fontSize: _small ? \"14\" : \"26\",\n                    _fontFamily: \"Norw, 'Courier New', monospace\",\n                    _coords: [\n                        \"60\",\n                        Util.uint256ToString(yOffset)\n                    ],\n                    _fill: \"white\",\n                    _attributes: \"\"\n                }),\n                Util.bytes32ToString(_text)\n            )\n        ;\n    }\n}\n"
    },
    "libraries/TextOf.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\nimport {SVG} from \"./SVG.sol\";\n\nlibrary TextOf {\n    /*//////////////////////////////////////////////////////////////\n                                 RENDER\n    //////////////////////////////////////////////////////////////*/\n\n    function render(bytes32 _text) internal pure returns (string memory) {\n        return\n            SVG.element(\n                \"text\",\n                SVG.textAttributes({\n                    _fontSize: \"26\",\n                    _fontFamily: \"Norw, 'Courier New', monospace\",\n                    _coords: [\"499\", \"605\"],\n                    _fill: \"white\",\n                    _attributes: 'text-anchor=\"end\"'\n                }),\n                Util.bytes32ToString(_text)\n            );\n    }\n}\n"
    },
    "libraries/Traits.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport {Util} from \"./Util.sol\";\n\nlibrary Traits {\n    /*//////////////////////////////////////////////////////////////\n                                 TRAITS\n    //////////////////////////////////////////////////////////////*/\n\n    function attributes(bytes32[] memory _attributeLabels, bytes32[] memory _attributeValues) internal pure returns (string memory) {\n        string memory result = \"[\";\n        // result = string.concat(result, _attribute(\"Density\", densityTrait(_seed, _tokenId)));\n        for (uint i; i < _attributeValues.length; i++) {\n            result = string.concat(result, _attribute(string(abi.encodePacked(_attributeLabels[i])), string(abi.encodePacked(_attributeValues[i]))));\n        }\n        return string.concat(result, \"]\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                INTERNAL\n    //////////////////////////////////////////////////////////////*/\n\n    function _attribute(string memory _traitType, string memory _value) internal pure returns (string memory) {\n        return string.concat(\"{\", Util.keyValue(\"trait_type\", _traitType), \",\", Util.keyValue(\"value\", _value), \"}\");\n    }\n\n    // function _rarity(bytes32 _seed, string memory _salt) internal pure returns (uint256) {\n    //     return uint256(keccak256(abi.encodePacked(_seed, _salt))) % 100;\n    // }\n}\n"
    },
    "libraries/Util.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nlibrary Util {\n    error NumberHasTooManyDigits();\n\n    /// @notice wraps a string in quotes and adds a space after\n    function quote(string memory value) internal pure returns (string memory) {\n        return string.concat('\"', value, '\" ');\n    }\n\n    function keyValue(string memory _key, string memory _value) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":\"', _value, '\"');\n    }\n\n    function keyValueNoQuotes(string memory _key, string memory _value) internal pure returns (string memory) {\n        return string.concat('\"', _key, '\":', _value);\n    }\n\n    /// @notice converts a tokenId to string and pads to _digits digits\n    /// @dev tokenId must be less than 10**_digits\n    /// @param _tokenId, uint256, the tokenId\n    /// @param _digits, uint8, the number of digits to pad to\n    /// @return result the resulting string\n    function uint256ToString(uint256 _tokenId, uint8 _digits) internal pure returns (string memory result) {\n        uint256 max = 10**_digits;\n        if (_tokenId >= max) revert NumberHasTooManyDigits();\n        // add leading zeroes\n        result = uint256ToString(_tokenId + max);\n        assembly {\n            // cut off one character\n            result := add(result, 1)\n            // store new length = _digits\n            mstore(result, _digits)\n        }\n    }\n\n    /// @notice converts a uint256 to ascii representation, without leading zeroes\n    /// @param _value, uint256, the value to convert\n    /// @return result the resulting string\n    function uint256ToString(uint256 _value) internal pure returns (string memory result) {\n        if (_value == 0) return \"0\";\n\n        assembly {\n            // largest uint = 2^256-1 has 78 digits\n            // reserve 110 = 78 + 32 bytes of data in memory\n            // (first 32 are for string length)\n\n            // get 110 bytes of free memory\n            result := add(mload(0x40), 110)\n            mstore(0x40, result)\n\n            // keep track of digits\n            let digits := 0\n\n            for {\n\n            } gt(_value, 0) {\n\n            } {\n                // increment digits\n                digits := add(digits, 1)\n                // go back one byte\n                result := sub(result, 1)\n                // compute ascii char\n                let c := add(mod(_value, 10), 48)\n                // store byte\n                mstore8(result, c)\n                // advance to next digit\n                _value := div(_value, 10)\n            }\n            // go back 32 bytes\n            result := sub(result, 32)\n            // store the length\n            mstore(result, digits)\n        }\n    }\n\n    function bytes1ToString(bytes1 _value) internal pure returns (string memory) {\n        return uint256ToString(uint8(_value));\n    }\n\n    function uint8ToString(uint8 _value) internal pure returns (string memory) {\n        return uint256ToString(_value);\n    }\n\n    /// @notice will revert in any characters are not in [0-9]\n    function stringToUint256(string memory _value) internal pure returns (uint256 result) {\n        // 0-9 are 48-57\n\n        bytes memory value = bytes(_value);\n        if (value.length == 0) return 0;\n        uint256 multiplier = 10**(value.length - 1);\n        uint256 i;\n        while (multiplier != 0) {\n            result += uint256((uint8(value[i]) - 48)) * multiplier;\n            unchecked {\n                multiplier /= 10;\n                ++i;\n            }\n        }\n    }\n\n    function bytes1ToHex(bytes1 _value) internal pure returns (string memory) {\n        bytes memory result = new bytes(2);\n        uint8 x = uint8(_value);\n\n        result[0] = getHexChar(x >> 4);\n        result[1] = getHexChar(x % 16);\n\n        return string(result);\n    }\n\n    function bytes32ToBytes(bytes32 x) internal pure returns (bytes memory) {\n        bytes memory bytesString = new bytes(32);\n        for (uint i = 0; i < 32; i++) {\n            if (x[i] == 0) {\n                bytesString[i] = bytes1(0x20);\n            } else {\n                bytesString[i] = x[i];\n            }\n        }\n        return abi.encodePacked(bytesString);\n    }\n\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\n        return string(bytes32ToBytes(x));\n    }\n\n    function getHexChar(uint8 _value) internal pure returns (bytes1) {\n        if (_value < 10) {\n            return bytes1(_value + 48);\n        }\n        _value -= 10;\n        return bytes1(_value + 97);\n    }\n\n    function stringToBytes1(string memory _value) internal pure returns (bytes1 result) {\n        return bytes1(uint8(stringToUint256(_value)));\n    }\n\n    function getRGBString(bytes memory _palette, uint256 _pos) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_palette[3 * _pos]),\n                Util.bytes1ToHex(_palette[3 * _pos + 1]),\n                Util.bytes1ToHex(_palette[3 * _pos + 2])\n            );\n    }\n\n    function getRGBString(bytes3 _color) internal pure returns (string memory result) {\n        return\n            string.concat(\n                \"#\",\n                Util.bytes1ToHex(_color[0]),\n                Util.bytes1ToHex(_color[1]),\n                Util.bytes1ToHex(_color[2])\n            );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}